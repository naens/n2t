class Parser {

    function Item addTerminal(Tokenizer tokenizer, Item parent, integer type) {
        var Item terminal;

        let terminal = tokenizer.nextToken();
        if (terminal = 0) {
            return 0;
        }
        if (~(terminal.getType() = type)) {
            do tokenizer.unread(terminal);
            return 0;
        }
        do parent.addSubItem(terminal);
        return terminal;
    }

    function Item parseDeclare(Tokenizer tokenizer) {
        return 0;
    }

    function Item parseIf(Tokenizer tokenizer) {
        var Item kw_if;
        var Item expr;
        var Item kw_then;
        var Item result;
        
        let result = Item.new();
        do result.setTerminal(false);
        do result.setType(Const.COND());

        let kw_if = Parser.addTerminal(tokenizer, result, Const.KW_IF());
        if (kw_if = 0) {
            do result.dispose();
            return 0;
        }

        let expr = Parser.parseExpression(true, tokenizer);
        if (expr = 0) {
            do result.dispose();
            return 0;
        }
        do result.addSubItem(expr);

        let kw_then = Parser.addTerminal(tokenizer, result, Const.KW_THEN());
        if (kw_then = 0) {
            do result.dispose();
            return 0;
        }

        return result;
    }

    function Item parseDo(Tokenizer tokenizer) {
        return 0;
    }

    function Item parseEnd(Tokenizer tokenizer) {
        var Item kw_end;
        var Item expr;
        var Item result;

        let result = Item.new();
        do result.setTerminal(false);
        do result.setType(Const.END());

        let kw_end = Parser.addTerminal(tokenizer, result, Const.KW_END());
        if (kw_end = 0) {
            do result.dispose();
            return 0;
        }

        do Parser.addTerminal(tokenizer, result, Const.IDENT());

        return result;
    }

    function Item parseReturn(Tokenizer tokenizer) {
        var Item kw_return;
        var Item expr;
        var Item result;

        let result = Item.new();
        do result.setType(Const.RETURN());

        let kw_return = Parser.addTerminal(tokenizer,
             result, Const.KW_RETURN());
        if (kw_return = 0) {
            do result.dispose();
            return 0;
        }

        let expr = Parser.parseExpression(true, tokenizer);
        if (~(expr = 0)) {
            do result.addSubItem(expr);
        }

        return result;
    }

    function Item parseAssign(Tokenizer tokenizer) {
        var Item ident;
        var Item ch_equals;
        var Item expr;
        var Item result;
        
        let result = Item.new();
        do result.setTerminal(false);
        do result.setType(Const.ASSIGN());

        let ident = Parser.addTerminal(tokenizer, result, Const.IDENT());
        if (ident = 0) {
            do result.dispose();
            return 0;
        }

        let ch_equals = Parser.addTerminal(tokenizer,
             result, Const.CH_EQUALS());
        if (ch_equals = 0) {
            do tokenizer.unread(ident);
            do result.dispose();
            return 0;
        }

        let expr = Parser.parseExpression(true, tokenizer);
        if (expr = 0) {
            do tokenizer.unread(ident);
            do tokenizer.unread(ch_equals);
            do result.dispose();
            return 0;
        }

        do result.addSubItem(expr);
        return result;
    }

    /* rel_op = "<" | ">" | "<=" | >=" | "<>" | "=" */
    function Item parseRelOp(Tokenizer tokenizer) {
        var Item i1;
        var Item i2;
        var Item result;
        var integer i1type;
        var integer i2type;

        let i1 = tokenizer.nextToken();
        if (i1 = 0) {
            return 0;
        }

        let result = Item.new();
        do result.setTerminal(false);
        do result.setType(Const.REL_OP());

        let i1type = i1.getType();
        if (i1type = Const.CH_EQUALS()) {
            do result.setType(Const.REL_OP());
            do result.addSubItem(i1);
            return result;
        } else {
            if ((i1.getType() = Const.CH_LOWER()) 
                | (i1.getType() = Const.CH_GREATER())) {
                do result.setType(Const.REL_OP());
                do result.addSubItem(i1);
            } else {
                do tokenizer.unread(i1);
                do result.dispose();
                return 0;
            }
        }

        let i2 = tokenizer.nextToken();
        if (i2 = 0) {
            do tokenizer.unread(i2);
            return result;
        }
        let i2type = i2.getType();
        if (((i1type = Const.CH_LOWER()) & ((i2type = Const.CH_EQUALS())
                                         | (i2type = Const.CH_GREATER())))
            | ((i1type = Const.CH_GREATER()) & (i2type = Const.CH_EQUALS()))) {
            do result.addSubItem(i2);
        } else {
            do tokenizer.unread(i2);
        }
        return result;
    }

    /* expr = arithm [ rel_op arithm ] */
    function Item parseExpression(boolean first, Tokenizer tokenizer) {
        var Item arithm;
        var Item rel_op;
        var Item result;

        let arithm = Parser.parseArithm(first, tokenizer);
        if (arithm = 0) {
            do Display.printConstln("expr:1");
            return 0;
        }
        let result = Item.new();
        do result.setTerminal(false);
        do result.setType(Const.EXPR());
        do result.addSubItem(arithm);

        let rel_op = Parser.parseRelOp(tokenizer);
        if (rel_op = 0) {
            do Display.printConstln("expr:2");
            return result;
        }
        let arithm = Parser.parseArithm(false, tokenizer);
        if (~(arithm = 0)) {
            do result.addSubItem(rel_op);
            do result.addSubItem(arithm);
        } else {
            do Display.printConstln("expr:3");
            do result.dispose();
            return 0; // error: rel_op without arithm
        }
        return result;
    }

    /* arithm = term {( "+" | "-" ) term } */
    function Item parseArithm(boolean first, Tokenizer tokenizer) {
        var Item term;
        var Item op;
        var Item result;

        do Display.printConstln("arithm:0");
        let term = Parser.parseTerm(first, tokenizer);
        if (term = 0) {
            do Display.printConstln("arithm:1");
            return 0;
        }

        let result = Item.new();
        do result.setTerminal(false);
        do result.setType(Const.ARITHM());
        do result.addSubItem(term);

        while (~(term = 0)) {
            do Display.printConstln("arithm:2");
            let op = tokenizer.nextToken();
            if (op = 0) {
                do Display.printConstln("arithm:2b");
                return result;
            }
            if ((~(op.getType() = Const.CH_PLUS()))
                 & (~(op.getType() = Const.CH_MINUS()))) {
                do tokenizer.unread(op);
                return result;
            }
            let term = Parser.parseTerm(false, tokenizer);
            if (~(term = 0)) {
                do result.addSubItem(op);
                do result.addSubItem(term);
            } else {
                do tokenizer.unread(op);
                return result;
            }
        }
        return result;
    }

    /* term = factor { ( "*" | "/" ) factor } */
    function Item parseTerm(boolean first, Tokenizer tokenizer) {
        var Item factor;
        var Item op;
        var Item result;

        do Display.printConstln("term:0");
        let factor = Parser.parseFactor(first, tokenizer);
        if (factor = 0) {
            do Display.printConstln("term:1");
            return 0;
        }

        let result = Item.new();
        do result.setTerminal(false);
        do result.setType(Const.TERM());
        do result.addSubItem(factor);

        while (~(factor = 0)) {
            do Display.printConstln("term:2");
            let op = tokenizer.nextToken();
            if (op = 0) {
                return result;
            }
            if ((~(op.getType() = Const.CH_STAR()))
                 & (~(op.getType() = Const.CH_SLASH()))) {
                do tokenizer.unread(op);
                return result;
            }
            let factor = Parser.parseFactor(false, tokenizer);
            if (~(factor = 0)) {
                do result.addSubItem(op);
                do result.addSubItem(factor);
            } else {
                do tokenizer.unread(op);
                return result;
            }
        }
        return result;
    }


    /* factor = [ "-" ]  number | ident | ( "(" ( ident {expr} ) | expr ")") */
    function Item parseFactor(boolean first, Tokenizer tokenizer) {
        var Item sign;
        var Item token;
        var Item expr; 
        var Item result;
        var Item token2;
        var Item token3;
        var integer tokenType;
        var integer token2type;
        var integer token3type;

        do Display.printConstln("factor:1");
        let sign = 0;

        let result = Item.new();
        do result.setTerminal(false);
        do result.setType(Const.FACTOR());

        let token = tokenizer.nextToken();
        if (token = 0) {
            do Display.printConstln("factor:1a");
            return 0;
        }
        let tokenType = token.getType();
        if (first) { // allow a minus prefix only for first factor of an arithm
            do Display.printConstln("factor:FIRST");

            if (tokenType = Const.CH_MINUS()) {
                let sign = token;
                let token = tokenizer.nextToken();
                if (token = 0) {
                    do tokenizer.unread(sign);
                    return 0;
                }
                do result.addSubItem(sign);
                let tokenType = token.getType();
            }
        }
        
        do Display.printConstln("factor:2");

        if ((tokenType = Const.T_INTEGER()) | (tokenType = Const.IDENT())) {
            do result.addSubItem(token);
            do Display.printConstln("factor:2a");
            return result;
        }

        do Display.printConstln("factor:3");

        if (~(tokenType = Const.CH_PAROP())) {
            do tokenizer.unread(token);
            if (~(sign = 0)) {
                do tokenizer.unread(sign);
            }
            do result.dispose();
            return 0;
        }

        do result.addSubItem(token);
        let token2 = tokenizer.nextToken();
        if (token2 = 0) {
        do Display.printConstln("factor:4");
            do tokenizer.unread(token);
            do result.dispose();
            return 0;
        }
        let token2type = token2.getType();
        if ((token2type = Const.CH_MINUS())
                 | (token2type = Const.T_INTEGER())
                 | (token2type = Const.CH_PAROP())) {
            do tokenizer.unread(token2);
            let expr = Parser.parseExpression(true, tokenizer);
            if (expr = 0) {
                do tokenizer.unread(token);
                do result.dispose();
                return 0;
            }
            do result.addSubItem(expr);
        } else {
            do Display.printConstln("factor:5");
            let token3 = tokenizer.nextToken();
            if (token3 = 0) {
                do tokenizer.unread(token2);
                do tokenizer.unread(token);
                do result.dispose();
                do Display.printConstln("factor:5a");
                return 0;
            }
            let token3type = token3.getType();
            do tokenizer.unread(token3);
            if ((token3type = Const.CH_EQUALS())
                | (token3type = Const.CH_PLUS())
                | (token3type = Const.CH_MINUS())
                | (token3type = Const.CH_GREATER())
                | (token3type = Const.CH_LOWER())
                | (token3type = Const.CH_STAR())
                | (token3type = Const.CH_SLASH())) {
                do Display.printConstln("factor:6");
                do tokenizer.unread(token2);
                let expr = Parser.parseExpression(true, tokenizer);
                if (expr = 0) {
                    do tokenizer.unread(token);
                    do result.dispose();
                    do Display.printConstln("factor:6a");
                    return 0;
                }
                do result.addSubItem(expr);
            } else {
                if (token2type = Const.IDENT()) {     //function call
                    do Display.printConstln("factor:7");
                    do result.addSubItem(token2);           //function name
                    let expr = Parser.parseExpression(false, tokenizer);
                    while (~(expr = 0)) {
                        do result.addSubItem(expr);         //parameters
                        let expr = Parser.parseExpression(false, tokenizer);
                    }
                }
            }
        }

        do Display.printConstln("factor:8");

        /* read closing parenthese */
        let token = tokenizer.nextToken();
        if (token = 0) {
            do result.dispose();
            do Display.printConstln("factor:8a");
            return 0;
        }
        if (~(token.getType() = Const.CH_PARCL())) {
            do result.dispose();
            do Display.printConstln("factor:8b");
            return 0;
        }

        do result.addSubItem(token);
        return result;
    }

    function Item parseLine(Tokenizer tokenizer) {
        var Item item;
        var integer type;
        let item = tokenizer.nextToken();

        if (item = 0) {
            return 0;
        }
        let type = item.getType();

        if (type = Const.KW_ELSE()) {
            return item;
        }

        do tokenizer.unread(item);

/*
        if (type = Const.KW_DECLARE()) {
            return Parser.parseDeclare(tokenizer);
        }
        if (type = Const.KW_IF()) {
            return Parser.parseIf(tokenizer);
        }
        if (type = Const.KW_ELSE()) {
            return tokenizer.nextToken();
        }
        if (type = Const.KW_DO()) {
            return Parser.parseDo(tokenizer);
        }
        if (type = Const.KW_END()) {
            return Parser.parseEnd(tokenizer);
        }
        if (type = Const.KW_RETURN()) {
            return Parser.parseReturn(tokenizer);
        }
        let item = Parser.parseAssign(tokenizer);
        if (~(item = 0)) {
            return item;
        }
        let item = Parser.parseExpression(tokenizer);
        if (~(item = 0)) {
            return item;
        }
        return 0;

//        if (type = Const.KW_SET()) {
//            return Parser.parseSet(tokenizer);
//        }
*/

        let item = Parser.parseExpression(true, tokenizer);
        if (item = 0) {
            do Display.printConstln("bad expression");
        } else {
            do Display.printConstln("parsing expression ok");
            do item.print();
            do Display.newline();
        }

        return 0;
        
    }

}
