class Parser {

    function Item addTerminal(Tokenizer tokenizer, Item parent, integer type) {
        var Item terminal;

        let terminal = tokenizer.nextToken();
        if (terminal = 0) {
            return 0;
        }
//        do Display.printConst("(((");
//        do terminal.print();
//        do Display.printConstln(")))");
        if (~(terminal.getType() = type)) {
            do tokenizer.unread(terminal);
            return 0;
        }
        do parent.addSubItem(terminal);
        return terminal;
    }

    /* var_decl = declare ident type */
    function Item parseVarDecl(Tokenizer tokenizer) {
        var Item kw_declare;
        var Item ident;
        var Item type;
        var Item result;
        
        let result = Item.new();
        do result.setTerminal(false);
        do result.setType(Const.VAR_DECL());

        let kw_declare = Parser.addTerminal(tokenizer, result, Const.KW_DECLARE());
        if (kw_declare = 0) {
            do result.dispose();
            return 0;
        }

        let ident = Parser.addTerminal(tokenizer, result, Const.IDENT());
        if (ident = 0) {
            do tokenizer.unread(kw_declare);
            do result.dispose();
            return 0;
        }

        let type = Parser.addTerminal(tokenizer, result, Const.RW_INTEGER());
        if (~(type = 0)) {
            return result;
        }
        let type = Parser.addTerminal(tokenizer, result, Const.RW_STRING());
        if (~(type = 0)) {
            return result;
        }
        let type = Parser.addTerminal(tokenizer, result, Const.RW_BOOLEAN());
        if (~(type = 0)) {
            return result;
        }

        do tokenizer.unread(ident);
        do tokenizer.unread(kw_declare);
        do result.dispose();
        return 0;
    }

    /* fun_stat = declare ( ident {ident} ) [type] */
    function Item parseFunStat(Tokenizer tokenizer) {
        var Item kw_declare;
        var Item par_op;
        var Item ident;
        var Item par_cl;
        var Item type;
        var Item result;
        
        let result = Item.new();
        do result.setTerminal(false);
        do result.setType(Const.FUN_STAT());

        let kw_declare = Parser.addTerminal(tokenizer, result, Const.KW_DECLARE());
        if (kw_declare = 0) {
            do result.dispose();
            return 0;
        }

        let par_op = Parser.addTerminal(tokenizer, result, Const.CH_PAROP());
        if (par_op = 0) {
            do tokenizer.unread(kw_declare);
            do result.dispose();
            return 0;
        }

        let ident = Parser.addTerminal(tokenizer, result, Const.IDENT());
        if (ident = 0) {
            do result.dispose();
            return 0;
        }
        while (~(ident = 0)) {
            let ident = Parser.addTerminal(tokenizer, result, Const.IDENT());
        }

        let par_cl = Parser.addTerminal(tokenizer, result, Const.CH_PARCL());
        if (par_cl = 0) {
            do result.dispose();
            return 0;
        }

        let type = Parser.addTerminal(tokenizer, result, Const.RW_INTEGER());
        if (~(type = 0)) {
            return result;
        }
        let type = Parser.addTerminal(tokenizer, result, Const.RW_STRING());
        if (~(type = 0)) {
            return result;
        }
        let type = Parser.addTerminal(tokenizer, result, Const.RW_BOOLEAN());
        if (~(type = 0)) {
            return result;
        }
        return result;

    }

    function Item parseDeclare(Tokenizer tokenizer) {
        var Item result;
        let result = Parser.parseVarDecl(tokenizer);
        if (~(result = 0)) {
            return result;
        }
        let result = Parser.parseFunStat(tokenizer);
        if (~(result = 0)) {
            return result;
        }
        return 0;
    }

    function Item parseIf(Tokenizer tokenizer) {
        var Item kw_if;
        var Item expr;
        var Item kw_then;
        var Item result;
        
        let result = Item.new();
        do result.setTerminal(false);
        do result.setType(Const.IF_STAT());

        let kw_if = Parser.addTerminal(tokenizer, result, Const.KW_IF());
        if (kw_if = 0) {
            do result.dispose();
            return 0;
        }

        let expr = Parser.parseExpression(true, tokenizer);
        if (expr = 0) {
            do result.dispose();
            return 0;
        }
        do result.addSubItem(expr);

        let kw_then = Parser.addTerminal(tokenizer, result, Const.KW_THEN());
        if (kw_then = 0) {
            do result.dispose();
            return 0;
        }

        return result;
    }

    function Item parseDoBlock(Tokenizer tokenizer) {
        var Item kw_do;
        var Item token;
        var Item result;
        
        let result = Item.new();
        do result.setTerminal(false);
        do result.setType(Const.DO_BLOCK_STAT());

        let kw_do = Parser.addTerminal(tokenizer, result, Const.KW_DO());
        if (kw_do = 0) {
            do result.dispose();
            return 0;
        }
        let token = tokenizer.nextToken();
        if (token = 0) {
            return result;
        }
        do tokenizer.unread(token);
        do tokenizer.unread(kw_do);
        do result.dispose();
        return 0;
    }

    /* do_iter = do ident = expr to expr [by expr] */
    function Item parseDoIter(Tokenizer tokenizer) {
        var Item kw_do;
        var Item token;
        var Item result;
        
        let result = Item.new();
        do result.setTerminal(false);
        do result.setType(Const.DO_ITER_STAT());

        let kw_do = Parser.addTerminal(tokenizer, result, Const.KW_DO());
        if (kw_do = 0) {
            do result.dispose();
            return 0;
        }

        let token = Parser.addTerminal(tokenizer, result, Const.IDENT());
        if (token = 0) {
            do tokenizer.unread(kw_do);
            do result.dispose();
            return 0;
        }

        let token = Parser.addTerminal(tokenizer, result, Const.CH_EQUALS());
        if (token = 0) {
            do result.dispose();
            return 0;
        }

        let token = Parser.parseExpression(true, tokenizer);
        if (token = 0) {
            do result.dispose();
            return 0;
        }
        do result.addSubItem(token);

        let token = Parser.addTerminal(tokenizer, result, Const.KW_TO());
        if (token = 0) {
            do result.dispose();
            return 0;
        }

        let token = Parser.parseExpression(true, tokenizer);
        if (token = 0) {
            do result.dispose();
            return 0;
        }
        do result.addSubItem(token);

        let token = Parser.addTerminal(tokenizer, result, Const.KW_BY());
        if (token = 0) {
            return result;
        }

        let token = Parser.parseExpression(true, tokenizer);
        if (token = 0) {
            do result.dispose();
            return 0;
        }
        do result.addSubItem(token);

        return result;
    }

    function Item parseDoWhile(Tokenizer tokenizer) {
        var Item kw_do;
        var Item kw_while;
        var Item expr;
        var Item result;

        let result = Item.new();
        do result.setTerminal(false);
        do result.setType(Const.DO_WHILE_STAT());

        let kw_do = Parser.addTerminal(tokenizer, result, Const.KW_DO());
        if (kw_do = 0) {
            do result.dispose();
            return 0;
        }

        let kw_while = Parser.addTerminal(tokenizer, result, Const.KW_WHILE());
        if (kw_while = 0) {
            do tokenizer.unread(kw_do);
            do result.dispose();
            return 0;
        }

        let expr = Parser.parseExpression(true, tokenizer);
        if (expr = 0) {
            do tokenizer.unread(kw_while);
            do tokenizer.unread(kw_do);
            do result.dispose();
            return 0;
        }
        do result.addSubItem(expr);

        return result;
    }

    function Item parseDo(Tokenizer tokenizer) {
        var Item result;
        let result = Parser.parseDoBlock(tokenizer);
        if (~(result = 0)) {
            return result;
        }
        let result = Parser.parseDoIter(tokenizer);
        if (~(result = 0)) {
            return result;
        }
        let result = Parser.parseDoWhile(tokenizer);
        if (~(result = 0)) {
            return result;
        }
        return 0;
    }

    function Item parseEnd(Tokenizer tokenizer) {
        var Item kw_end;
        var Item expr;
        var Item result;

        let result = Item.new();
        do result.setTerminal(false);
        do result.setType(Const.END());

        let kw_end = Parser.addTerminal(tokenizer, result, Const.KW_END());
        if (kw_end = 0) {
            do result.dispose();
            return 0;
        }

        do Parser.addTerminal(tokenizer, result, Const.IDENT());

        return result;
    }

    function Item parseReturn(Tokenizer tokenizer) {
        var Item kw_return;
        var Item expr;
        var Item result;

        let result = Item.new();
        do result.setType(Const.RETURN());

        let kw_return = Parser.addTerminal(tokenizer,
             result, Const.KW_RETURN());
        if (kw_return = 0) {
            do result.dispose();
            return 0;
        }

        let expr = Parser.parseExpression(true, tokenizer);
        if (~(expr = 0)) {
            do result.addSubItem(expr);
        }

        return result;
    }

    function Item parseAssign(Tokenizer tokenizer) {
        var Item ident;
        var Item ch_equals;
        var Item expr;
        var Item result;
        
        let result = Item.new();
        do result.setTerminal(false);
        do result.setType(Const.ASSIGN());

        let ident = Parser.addTerminal(tokenizer, result, Const.IDENT());
        if (ident = 0) {
            do result.dispose();
            return 0;
        }

        let ch_equals = Parser.addTerminal(tokenizer,
             result, Const.CH_EQUALS());
        if (ch_equals = 0) {
            do tokenizer.unread(ident);
            do result.dispose();
            return 0;
        }

        let expr = Parser.parseExpression(true, tokenizer);
        if (expr = 0) {
            do tokenizer.unread(ident);
            do tokenizer.unread(ch_equals);
            do result.dispose();
            return 0;
        }

        do result.addSubItem(expr);
        return result;
    }

    /* expr = [not] log_expr { (and | or ) expr } */
    function Item parseExpression(boolean first, Tokenizer tokenizer) {
        var Item kw_not;
        var Item log_expr;
        var Item op;
        var Item expr;
        var Item result;

        let result = Item.new();
        do result.setTerminal(false);
        do result.setType(Const.EXPR());

//        do Display.printConstln("expr:001");

        let kw_not = Parser.addTerminal(tokenizer, result, Const.KW_NOT());

//        do Display.printConstln("expr:002");
        let log_expr = Parser.parseLogExpr(first, tokenizer);
        if (log_expr = 0) {
//            do Display.printConstln("expr:0a");
            if (~(kw_not = 0)) {
                do tokenizer.unread(kw_not);
            }
            return 0;
        }
        do result.addSubItem(log_expr);


        while (~(log_expr = 0)) {
//            do Display.printConstln("expr:1");
            let op = tokenizer.nextToken();
            if (op = 0) {
//                do Display.printConstln("expr:1b");
                return result;
            }
            if ((~(op.getType() = Const.KW_AND()))
                 & (~(op.getType() = Const.KW_OR()))) {
                do tokenizer.unread(op);
                return result;
            }
            // no problem having unary minus after and / or
            let expr = Parser.parseExpression(true, tokenizer);
            if (~(expr = 0)) {
                do result.addSubItem(op);
                do result.addSubItem(expr);
            } else {
                do tokenizer.unread(op);
                return result;
            }
        }
        return result;
    }

    /* rel_op = "<" | ">" | "<=" | >=" | "<>" | "=" */
    function Item parseRelOp(Tokenizer tokenizer) {
        var Item i1;
        var Item i2;
        var Item result;
        var integer i1type;
        var integer i2type;

        let i1 = tokenizer.nextToken();
        if (i1 = 0) {
            return 0;
        }

        let result = Item.new();
        do result.setTerminal(false);
        do result.setType(Const.REL_OP());

        let i1type = i1.getType();
        if (i1type = Const.CH_EQUALS()) {
            do result.setType(Const.REL_OP());
            do result.addSubItem(i1);
            return result;
        } else {
            if ((i1.getType() = Const.CH_LOWER()) 
                | (i1.getType() = Const.CH_GREATER())) {
                do result.setType(Const.REL_OP());
                do result.addSubItem(i1);
            } else {
                do tokenizer.unread(i1);
                do result.dispose();
                return 0;
            }
        }

        let i2 = tokenizer.nextToken();
        if (i2 = 0) {
            do tokenizer.unread(i2);
            return result;
        }
        let i2type = i2.getType();
        if (((i1type = Const.CH_LOWER()) & ((i2type = Const.CH_EQUALS())
                                         | (i2type = Const.CH_GREATER())))
            | ((i1type = Const.CH_GREATER()) & (i2type = Const.CH_EQUALS()))) {
            do result.addSubItem(i2);
        } else {
            do tokenizer.unread(i2);
        }
        return result;
    }

    /* log_expr = true | false | (arithm [ rel_op arithm ]) */
    function Item parseLogExpr(boolean first, Tokenizer tokenizer) {
        var Item bool;
        var Item arithm;
        var Item rel_op;
        var Item result;

        let result = Item.new();
        do result.setTerminal(false);
        do result.setType(Const.LOG_EXPR());

        let bool = Parser.addTerminal(tokenizer, result, Const.T_BOOLEAN());
        if (~(bool = 0)) {
            return result;
        }

        let arithm = Parser.parseArithm(first, tokenizer);
        if (arithm = 0) {
//            do Display.printConstln("log_expr:1");
            do result.dispose();
            return 0;
        }
        do result.addSubItem(arithm);

        let rel_op = Parser.parseRelOp(tokenizer);
        if (rel_op = 0) {
//            do Display.printConstln("log_expr:2");
            return result;
        }
        // no problem having unary minus after rel_op
        let arithm = Parser.parseArithm(true, tokenizer);
        if (~(arithm = 0)) {
            do result.addSubItem(rel_op);
            do result.addSubItem(arithm);
        } else {
//            do Display.printConstln("log_expr:3");
            do result.dispose();
            return 0; // error: rel_op without arithm
        }
        return result;
    }

    /* arithm = term {( "+" | "-" ) term } */
    function Item parseArithm(boolean first, Tokenizer tokenizer) {
        var Item term;
        var Item op;
        var Item result;

//        do Display.printConstln("arithm:0");
        let term = Parser.parseTerm(first, tokenizer);
        if (term = 0) {
//            do Display.printConstln("arithm:1");
            return 0;
        }

        let result = Item.new();
        do result.setTerminal(false);
        do result.setType(Const.ARITHM());
        do result.addSubItem(term);

        while (~(term = 0)) {
//            do Display.printConstln("arithm:2");
            let op = tokenizer.nextToken();
            if (op = 0) {
//                do Display.printConstln("arithm:2b");
                return result;
            }
            if ((~(op.getType() = Const.CH_PLUS()))
                 & (~(op.getType() = Const.CH_MINUS()))) {
                do tokenizer.unread(op);
                return result;
            }
            let term = Parser.parseTerm(false, tokenizer);
            if (~(term = 0)) {
                do result.addSubItem(op);
                do result.addSubItem(term);
            } else {
                do tokenizer.unread(op);
                return result;
            }
        }
        return result;
    }

    /* term = factor { ( "*" | "/" | mod ) factor } */
    function Item parseTerm(boolean first, Tokenizer tokenizer) {
        var Item factor;
        var Item op;
        var Item result;

//        do Display.printConstln("term:0");
        let factor = Parser.parseFactor(first, tokenizer);
        if (factor = 0) {
//            do Display.printConstln("term:1");
            return 0;
        }

        let result = Item.new();
        do result.setTerminal(false);
        do result.setType(Const.TERM());
        do result.addSubItem(factor);

        while (~(factor = 0)) {
//            do Display.printConstln("term:2");
            let op = tokenizer.nextToken();
            if (op = 0) {
                return result;
            }
            if ((~(op.getType() = Const.CH_STAR()))
                & (~(op.getType() = Const.CH_SLASH()))
                & (~(op.getType() = Const.KW_MOD()))) {
//                do Display.printConstln("term:3");
                do tokenizer.unread(op);
                return result;
            }
//            do Display.printConstln("term:4");
            let factor = Parser.parseFactor(false, tokenizer);
            if (~(factor = 0)) {
//                do Display.printConstln("term:4a");
                do result.addSubItem(op);
                do result.addSubItem(factor);
            } else {
//                do Display.printConstln("term:4b");
                do tokenizer.unread(op);
                return result;
            }
        }
        return result;
    }

    /* call = ident expr {expr} */
    function Item parseCall(Tokenizer tokenizer) {
        var Item ident;
        var Item expr;
        var Item result;

        let result = Item.new();
        do result.setTerminal(false);
        do result.setType(Const.CALL());

        let ident = Parser.addTerminal(tokenizer, result, Const.IDENT());
        if (ident = 0) {
            return 0;
        }

        let expr = Parser.parseExpression(false, tokenizer);
        if (expr = 0) {
            do tokenizer.unread(ident);
            do result.dispose();
            return 0;
        }
        do result.addSubItem(expr);
        let expr = Parser.parseExpression(false, tokenizer);
        while (~(expr = 0)) {
            do result.addSubItem(expr);
            let expr = Parser.parseExpression(false, tokenizer);
        }
        return result;
    }

    /* factor= [ "-" ]  number | ident | ( "(" call | expr ")") */
    function Item parseFactor(boolean first, Tokenizer tokenizer) {
        var Item sign;
        var Item token;
        var Item call;
        var Item expr; 
        var Item result;
        var integer tokenType;

//        do Display.printConstln("factor:1");
        let sign = 0;

        let result = Item.new();
        do result.setTerminal(false);
        do result.setType(Const.FACTOR());

        let token = tokenizer.nextToken();
        if (token = 0) {
            do Display.printConstln("factor:1a");
            return 0;
        }
//        do Display.printConst("<<<");
//        do token.print();
//        do Display.printConstln(">>>");
        let tokenType = token.getType();
        if (first) { // allow a minus prefix only for first factor of an arithm
//            do Display.printConstln("factor:FIRST");

            if (tokenType = Const.CH_MINUS()) {
                let sign = token;
                let token = tokenizer.nextToken();
                if (token = 0) {
                    do tokenizer.unread(sign);
                    return 0;
                }
                do result.addSubItem(sign);
                let tokenType = token.getType();
            }
        }
        
//        do Display.printConstln("factor:2");

        if ((tokenType = Const.T_INTEGER()) | (tokenType = Const.IDENT())) {
            do result.addSubItem(token);
//            do Display.printConstln("factor:2a");
            return result;
        }
//        do Display.printConst("<<<");
//        do token.print();
//        do Display.printConstln(">>>");

//        do Display.printConstln("factor:3");

        if (~(tokenType = Const.CH_PAROP())) {
            do tokenizer.unread(token);
            if (~(sign = 0)) {
                do tokenizer.unread(sign);
            }
            do result.dispose();
            return 0;
        }

        let call = Parser.parseCall(tokenizer);
        if (~(call = 0)) {
            do result.addSubItem(call);
        } else {
            let expr = Parser.parseExpression(true, tokenizer);
            if (expr = 0) {
                do tokenizer.unread(token);
                do result.dispose();
                return 0;
            }
            do result.addSubItem(expr);
        }

//        do Display.printConstln("factor:8");

        /* read closing parenthese */
        let token = tokenizer.nextToken();
        if (token = 0) {
            do result.dispose();
//            do Display.printConstln("factor:8a");
            return 0;
        }
        if (~(token.getType() = Const.CH_PARCL())) {
            do result.dispose();
//            do Display.printConstln("factor:8b");
            return 0;
        }

        do result.addSubItem(token);
        return result;
    }

    function Item parseLine(Tokenizer tokenizer) {
        var Item item;
        var integer type;

        let item = tokenizer.nextToken();
        if (item = 0) {
            return 0;
        }
        let type = item.getType();

        if (type = Const.KW_ELSE()) {
            return item;
        }

        do tokenizer.unread(item);


        if (type = Const.KW_DECLARE()) {
            return Parser.parseDeclare(tokenizer);
        }
        if (type = Const.KW_IF()) {
            return Parser.parseIf(tokenizer);
        }
        if (type = Const.KW_ELSE()) {
            return tokenizer.nextToken();
        }
        if (type = Const.KW_DO()) {
            return Parser.parseDo(tokenizer);
        }
        if (type = Const.KW_END()) {
            return Parser.parseEnd(tokenizer);
        }
        if (type = Const.KW_RETURN()) {
            return Parser.parseReturn(tokenizer);
        }
        let item = Parser.parseAssign(tokenizer);
        if (~(item = 0)) {
            return item;
        }
        let item = Parser.parseCall(tokenizer);
        if (~(item = 0)) {
            return item;
        }

        let item = Parser.parseExpression(true, tokenizer);
        if (~(item = 0)) {
            return item;
        }

        return 0;
        
    }

}
