class Eva {
    /* 2-pass Evaluator
     * 1st pass: determine the block for each variable
                 link identifier objects to function if is a function
     * 2nd pass: execute the item
     *
     * The evaluator needs to keep the variable values, they are stored
     * in object fields.
     */
    
    field IdentMap identMap;

    field integer lastBlockId;
    field integer currBlockId;

    field List blockIdStack;

    method void nextBlockId() {
//        do Display.printConstln("nextBlockId");
        let lastBlockId = lastBlockId + 1;
        let blockIdStack = blockIdStack.prepend(lastBlockId);
        let currBlockId = lastBlockId;
        return;
    }

    method void popBlockId() {
//        do Display.printConstln("popBlockId");
        let blockIdStack = blockIdStack.deleteFirst();
        let currBlockId = blockIdStack.get();
        return;
    }

    constructor Eva new() {
        let identMap = IdentMap.new();
        let lastBlockId = 0;
        let blockIdStack = List.new(lastBlockId);
        let currBlockId = 0;
        return this;
    }

    /* returns true if variable already declared in ident map
     * + print error message
     */
    function boolean checkDeclared(IdentMap identMap,
      String name, integer blockId) {
        var Element element;
        let element = identMap.get(name, blockId);
        if (element = 0) {
            return false;
        } else {
            do Display.printConst("Identifier with name ");
            do Display.printString(name);
            do Display.printConstln(" is already declared in the block.");
            return true;
        }
    }

    /* pass1: variable declaration: save in block id in vartable
     *        procedure declaration: save in block id in vartable
     *                               save in identmap
     *        variable in code: set block id from vartable
     *        procedure in code: set procedure node from identmap
     * !! when identifier in code: first find block id
     *                             then check identmap (present => proc)
     *                             if procedure: link occurence to node
     & return value: true on success, false on error
     */
    method boolean pass1rec(VarTable varTable, Item item) {
        var String identName;
        var String varName;
        var String procName;
        var integer identBlockId;
        var integer endBlockId;
        var integer tmp;
        var integer type;
        var List subItems;
        var List procArgs;
        var Item procIdent;
        var Item arg;
        var Item subItem;
        if (item.isTerminal()) {
            if (item.getType() = Const.IDENT()) {
                let identName = AstSel.identName(item);
                let identBlockId = varTable.get(identName);
                if (identBlockId = (-1)) {
                    if (~(identMap.get(identName, 0) = 0)) {
                        do item.setBlockId(0);
                    } else {
                        do item.setBlockId(-1);
                        do Display.printConst("Identifier ");
                        do Display.printString(identName);
                        do Display.printConstln(" undefined.");
                        return false;
                    }
                } else {
                    do item.setBlockId(identBlockId);
                }
            }
            return true;
        }

        if (item.getType() = Const.VAR_DECL()) {
            let varName = AstSel.varName(item);
            let type = AstSel.varType(item);
            if (currBlockId > 0) {
                if (Eva.checkDeclared(identMap, varName, currBlockId)) {
                    return false;
                }
            }
            do pass1rec(varTable, AstSel.varRest(item));
            do identMap.putVar(varName, currBlockId, type);
            do varTable.put(varName, currBlockId);
            do item.setBlockId(currBlockId);
            return true;
        }

        if (item.getType() = Const.PROC_DECL()) {
            let procName = AstSel.procName(item);
            if (currBlockId > 0) {
                if (Eva.checkDeclared(identMap, procName, currBlockId)) {
                    return false;
                }
            }
            do varTable.put(procName, currBlockId);
            do identMap.putProc(procName, currBlockId, item);
            let procIdent = AstSel.procIdent(item);
            do procIdent.setBlockId(currBlockId);
            do nextBlockId();
            let procArgs = AstSel.procArgs(item);
            while (~(procArgs = 0)) {
                let arg = procArgs.get();
                do arg.setBlockId(currBlockId);
                let procArgs = procArgs.getNext();
            }
            let subItems = AstSel.procRest(item);
            do item.setBlockId(currBlockId);
        } else {
            if ((item.getType() = Const.DO_BLOCK())
              | ((item.getType() = Const.DO_ITER())
                 | (item.getType() = Const.DO_WHILE()))) {
                do pass1rec(varTable, AstSel.blockStat(item));
                do nextBlockId();
                do item.setBlockId(currBlockId);
                let subItems = AstSel.blockRest(item);
            } else {
                let subItems = item.getSubItems();
            }
        }
        while (~(subItems = 0)) {
            if (~pass1rec(varTable, subItems.get())) {
                return false;
            }
            let subItems = subItems.getNext();
        }
        if (item.getType() = Const.END_STAT()) {
//                let endBlockId = topBlockId();
//                do Display.printConstln("set end blockId:");
//                do Display.printInt(endBlockId);
//                do Display.newline();
            do item.setBlockId(currBlockId);
            do varTable.popBlock(currBlockId);
            do popBlockId();
        }
        return true;
    }

    /* return true on success, false on error */
    method boolean pass1(Item item) {
        var boolean result;
        var VarTable varTable;
        let varTable = VarTable.new();
        let result = pass1rec(varTable, item);
        do varTable.dispose();
        return result;
    }

    /* return value of a constant, variable or function call */
    method Value evalTerminal(IdentMap identMap, Item item) {
        var String name;
        var integer blockId;
        var Element element;

        if (item.getType() = Const.IDENT()) {
            let name = AstSel.identName(item);
            let blockId = item.getBlockId();
            if (blockId = (-1)) {
                /* unknown (undeclared) identifier error */
                return 0;
            }
            let element = identMap.get(name, blockId);
            if (element.getType() = Const.T_PROCEDURE()) {
                /* procedure call */
                /* TODO */
                return 0;
            } else {
                /* get variable value */
                let element = identMap.get(name, blockId);
                return element.getValue();
            }
        }

        /* return constant value */
        return item.getValue();
    }

    /* executes a procedure call and returns a value if value returned */
    method Value execCall(IdentMap identMap, Item item) {
        /* TODO */
        return 0;
    }

    /* returns the value of the expression */
    method Value evalExpr(IdentMap identMap, Item item) {
        /* TODO */
        return 0;
    }

    method void execAssignment(Item item) {
        /* TODO */
        return;
    }

    method void execDoBlock(Item item) {
        /* TODO */
        return;
    }

    method void execDoIter(Item item) {
        /* TODO */
        return;
    }

    method void execDoWhile(Item item) {
        /* TODO */
        return;
    }

    /* only assignments, calls, exprs and blocks go here */
    method Value execute(IdentMap identMap, Item item) {
        if (item.getType() = Const.ASSIGN()) {
            do execAssignment(item);
            return 0;
        }

        if (item.getType() = Const.CALL()) {
            return execCall(identMap, item);
        }

        if (item.getType() = Const.EXPR()) {
            return evalExpr(identMap, item);
        }

        if (item.getType() = Const.DO_BLOCK()) {
            do execDoBlock(item);
            return 0;
        }

        if (item.getType() = Const.DO_ITER()) {
            do execDoIter(item);
            return 0;
        }

        if (item.getType() = Const.DO_WHILE()) {
            do execDoWhile(item);
            return 0;
        }
        return 0;
    }

    /* execute method: performs the two passes */
    method Value evaluate(Item item) {
        if (pass1(item)) {
            do AstPrint.item(identMap, item);
            return execute(identMap, item);
        } else {
            do Display.printConstln("Pass1 failed.");
            return 0;
        }
    }

    method void dispose() {
        do identMap.dispose();
        do Memory.deAlloc(this);
        return;
    }

}
