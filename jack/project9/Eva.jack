class Eva {
    /* 2-pass Evaluator
     * 1st pass: determine the block for each variable
                 link identifier objects to function if is a function
     * 2nd pass: execute the item
     *
     * The evaluator needs to keep the variable values, they are stored
     * in object fields.
     */
    
    field IdentMap identMap;

    field integer lastBlockId;
    field integer currBlockId;

    field List blockIdStack;

    method void nextBlockId() {
        let lastBlockId = lastBlockId + 1;
        let blockIdStack = blockIdStack.prepend(lastBlockId);
        let currBlockId = lastBlockId;
        return;
    }

    method void popBlockId() {
        let blockIdStack = blockIdStack.deleteFirst();
        let currBlockId = blockIdStack.get();
        return;
    }

    constructor Eva new() {
        let identMap = IdentMap.new();
        let lastBlockId = 0;
        let blockIdStack = List.new(lastBlockId);
        let currBlockId = 0;
        return this;
    }

    /* pass1: variable declaration: save in block id in vartable
     *        procedure declaration: save in block id in vartable
     *                               save in identmap
     *        variable in code: set block id from vartable
     *        procedure in code: set procedure node from identmap
     * !! when identifier in code: first find block id
     *                             then check identmap (present => proc)
     *                             if procedure: link occurence to node
     */
    method void pass1rec(VarTable varTable, Item item) {
        var String identName;
        var String varName;
        var String funName;
        var integer identBlockId;
        var integer endBlockId;
        var integer tmp;
        var integer type;
        var List subItems;
        var List funArgs;
        var Item arg;
        var Item subItem;
        if (item.isTerminal()) {
            if (item.getType() = Const.IDENT()) {
                let identName = AstSel.identName(item);
                let identBlockId = varTable.get(identName);
                if (identBlockId = -1) {
                    if ((currBlockId = 0)
                      & (~(identMap.get(identName, 0) = 0))) {
                        do item.setBlockId(0);
                    } else {
                        do item.setBlockId(-1);
                    }
                } else {
                    do item.setBlockId(identBlockId);
                }
            }
            return;
        } else {
            if (item.getType() = Const.VAR_DECL()) {
                let varName = AstSel.varName(item);
                let type = AstSel.varType(item);
                do pass1rec(varTable, AstSel.varRest(item));
                do identMap.putVar(varName, currBlockId, type);
                do varTable.put(varName, currBlockId);
                do item.setBlockId(currBlockId);
                return;
            } else {
                if (item.getType() = Const.FUN_DECL()) {
                    let funName = AstSel.funName(item);
                    do varTable.put(funName, currBlockId);
                    do identMap.putProc(funName, currBlockId, item);
/*
                    do Display.printConst("putProc:");
                    do Display.printString(funName);
                    do Display.printConst(":");
                    do Display.printInt(currBlockId);
                    do Display.newline();
*/
                    do nextBlockId();
                    let funArgs = AstSel.funArgs(item);
                    while (~(funArgs = 0)) {
                        let arg = funArgs.get();
                        do arg.setBlockId(currBlockId);
                        let funArgs = funArgs.getNext();
                    }
                    let subItems = AstSel.funRest(item);
                    do item.setBlockId(currBlockId);
                } else {
                    if (item.getType() = Const.DO_BLOCK()
                      | item.getType() = Const.DO_ITER()
                      | item.getType() = Const.DO_WHILE()) {
                        do pass1rec(varTable, AstSel.blockStat(item));
                        do nextBlockId();
                        do item.setBlockId(currBlockId);
                        let subItems = AstSel.blockRest(item);
                    } else {
                        let subItems = item.getSubItems();
                    }
                }
            }
            while (~(subItems = 0)) {
                do pass1rec(varTable, subItems.get());
                let subItems = subItems.getNext();
            }

            if (item.getType() = Const.END_STAT()) {
//                let endBlockId = topBlockId();
//                do Display.printConstln("set end blockId:");
//                do Display.printInt(endBlockId);
//                do Display.newline();
                do item.setBlockId(currBlockId);
                do varTable.popBlock(currBlockId);
                do popBlockId();
                return;
            }
            return;
        }
    }

    method void pass1(Item item) {
        var VarTable varTable;
        let varTable = VarTable.new();
        do pass1rec(varTable, item);
        do varTable.dispose();
        return;
    }

    method Value execute(Item item) {
        /* TODO */
        return item;
    }

    /* execute method: performs the two passes */
    method Value evaluate(Item item) {
        do pass1(item);
        do AstPrint.item(identMap, item);
        return execute(item);
    }

    method void dispose() {
        do identMap.dispose();
        do Memory.deAlloc(this);
        return;
    }

}
